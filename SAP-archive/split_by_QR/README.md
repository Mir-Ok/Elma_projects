# Разделение одного файла на фрагменты в соответствии с QR-кодами

## Технологии

    Python 3.8, Flask, requests, pydantic, Pillow, pdf2image, loguru

## Задача

Создать в микросервисе метод по конвертации файлов pdf и tiff - split_by_qr, 
который проверяет все страницы документа на наличие QR-кода.
Код распознается, оцифровывается и отправляется на сервер в итоговом отчете.

Если его в документе нет, то файл переводится в PDF-формат и сохраняется на 
сервере в неизменном виде.
Если QR-код встречается в документе 1 и более раз, метод разделяет документ
на последовательные фрагменты таким образом, что каждый из них стартует с кода.
В случае, когда первый код обнаруживается не с первой страницы - все пустые 
страницы удаляются, до первого QR-кода.

### Тело запроса

Скрипт начинает работу с приема параметров из входящего POST-запроса, который 
содержит в себе имя файла, его идентификатор на сайте и шаблон.
При помощи библиотеки Pydantic данные проходят валидацию. Формат json:

```json
[
  {
     "s3uid": "050c9bbd-d8bf-413a-b7ef-7a184190ddf9",
     "filename": "stream_sample.tiff",
     "regexp": "SAP-"
   }
]
```

Идентификатор используется для формирования ссылки на скачивание.
Скрипт разделяет имя файла на имя и суффикс. Это нужно для того, чтобы 
использовать исходное название в итоговых фрагментах, а так же для определения
формата документа.
Файлы PDF и TIFF требуют разных подходов, поэтому для их разбиения на страницы 
используются разные библиотеки.


### endpoint

После того как страницы распознаны, при необходимости разделены и перекомпонованы,
новые документы отправляются на Elma. Каждый документ имеет свой идентификатор
`hash_file: str` - UID файла:

- [**POST**] ```/pub/v1/disk/file/upload?hash={hash_file}```


## Примеры ответа сервера

#### HTTP 201 - загрузка прошла успешно

```json
{
    "data": {
        "totally_pages": 15,
        "documents": [
            {
                "sequence": 0,
                "qr_value": "SAP-1",
                "pages": {
                    "from": 0,
                    "to": 5
                },
                "s3uid": "6d73e562-ab79-42f1-92c3-9a8626828be9",
                "filename": "stream_sample.tiff_kiE_(0).pdf"
            },
            {
                "sequence": 1,
                "qr_value": "SAP-3",
                "pages": {
                    "from": 6,
                    "to": 8
                },
                "s3uid": "9f8dca8f-787f-4435-8cc4-e546321f1e07",
                "filename": "stream_sample.tiff_ktQ_(1).pdf"
            },
            {
                "sequence": 2,
                "qr_value": "SAP-2",
                "pages": {
                    "from": 9,
                    "to": 10
                },
                "s3uid": "20402d52-7fa8-4f23-a0d2-265e14e7593b",
                "filename": "stream_sample.tiff_GRB_(2).pdf"
            },
            {
                "sequence": 3,
                "qr_value": "SAP-4",
                "pages": {
                    "from": 11,
                    "to": 14
                },
                "s3uid": "e372aae1-4e96-49fc-b672-beb0c1283e6f",
                "filename": "stream_sample.tiff_lmR_(3).pdf"
            }
        ]
    },
    "error": null
}
```

#### HTTP 400 - ошибка получения файла

Входящий запрос принес некорректное имя файла:

```json
{
    "data": null,
    "error": [
        {
            "body_params": [
                {
                    "loc": [
                        "filename"
                    ],
                    "msg": "string does not match regex \"[a-zA-Z0-9_.]{1,}[.](jpg|jpeg|png|bmp|tiff|tif|pdf)\\b\"",
                    "type": "value_error.str.regex",
                    "ctx": {
                        "pattern": "[a-zA-Z0-9_.]{1,}[.](jpg|jpeg|png|bmp|tiff|tif|pdf)\\b"
                    }
                }
            ]
        }
    ]
}
```

#### HTTP 501 - ошибка скачивания файла
 
```json
{
    "data": null,
    "error": "Ссылка на скачивание файла не получена"
}
```